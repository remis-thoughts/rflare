#!/usr/bin/env ruby

require 'csv'
require 'optparse'
require 'json'
require 'flash'

csv_opts = {}
csv_file = nil
json = {}

OptionParser.new do |opts|
  opts.banner = "Usage: flash.rb [options]"

  opts.on("-F", "--field-separator [FS]") do |fs|
    csv_opts[:col_sep] = fs
  end

  opts.on("-f", "--file [FILE]") do |file|
    csv_file = file
  end

  opts.on("-q", "--query [QUERY]") do |q|
    json = JSON.parse(File.read(q), :symbolize_names => true)
  end
end.parse!

ss = Spreadsheet.new(csv_file ? CSV.read(csv_file, csv_opts) : [])
nodes = (json[:nodes] || [{id: 0}]).map { |node| 
  Node.new node, ss.row_bounds, ss.col_bounds
}
edges = (json[:edges] || []).map {|edge| Edge.new edge}
outputs = json[:outputs] || []
root = nodes[0]

edges_byfrom = Hash.new {|h,k| h[k] = [] }
edges.map {|edge| edges_byfrom[edge.from] << edge }
nodes_byid = Hash.new nodes.map {|node| [node.id, node]}

def matches row, col, node, ss, edges_byfrom, nodes_byid
  return [] if !node.matches(ss, row, col)
  me = {node[:id] => ss[row,col]}
  edges = edges_byfrom[node[:id]]
  return me if edges.empty?
  edge_matches = edges.map {|edge|
  }

end

# start at root, looking for trees
root.each {|row, col|
  matches(row, col, root, ss, edges_byfrom, nodes_byid) { |match|
    puts outputs.map {|output| match[output] || ''}.join '\t'
  }
}

